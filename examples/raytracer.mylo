// --- Vector Math & Structs ---
struct Vec3 {
    var x
    var y
    var z
}

fn add_v(a: Vec3, b: Vec3) {
    var r: Vec3 = {x: a.x + b.x, y: a.y + b.y, z: a.z + b.z}
    ret r
}

fn sub_v(a: Vec3, b: Vec3) {
    var r: Vec3 = {x: a.x - b.x, y: a.y - b.y, z: a.z - b.z}
    ret r
}

fn mul_vs(a: Vec3, s: num) {
    var r: Vec3 = {x: a.x * s, y: a.y * s, z: a.z * s}
    ret r
}

fn mul_v(a: Vec3, b: Vec3) {
    var r: Vec3 = {x: a.x * b.x, y: a.y * b.y, z: a.z * b.z}
    ret r
}

fn dot(a: Vec3, b: Vec3) {
    ret a.x * b.x + a.y * b.y + a.z * b.z
}

fn norm(v: Vec3) {
    var mag = sqrt(dot(v, v))
    if (mag == 0) {
        var z: Vec3 = {x:0, y:0, z:0}
        ret z
    }
    var r: Vec3 = {x: v.x/mag, y: v.y/mag, z: v.z/mag}
    ret r
}

fn reflect(v: Vec3, n: Vec3) {
    var dot_vn = dot(v, n)
    var n_scaled = mul_vs(n, 2 * dot_vn)
    ret sub_v(v, n_scaled)
}

fn random_unit_vector() {
    var v: Vec3 = {x: rand_normal(), y: rand_normal(), z: rand_normal()}
    ret norm(v)
}

// --- Scene Definitions ---
enum Material {
    diffuse,
    metal
}

struct Ray {
    var o: Vec3
    var d: Vec3
}

struct Sphere {
    var r
    var p: Vec3
    var c: Vec3
    var mat_type
    var fuzz
}

// --- Render Settings ---
var width = 1920
var height = 1080
var samples = 10
var max_depth = 5

// --- Core Raytracing ---
fn intersect(ray: Ray, sph: Sphere) {
    var p: Vec3 = sph.p
    var o: Vec3 = ray.o
    var d: Vec3 = ray.d

    var op_x = p.x - o.x
    var op_y = p.y - o.y
    var op_z = p.z - o.z

    var b = (op_x * d.x) + (op_y * d.y) + (op_z * d.z)
    var dot_op = (op_x * op_x) + (op_y * op_y) + (op_z * op_z)

    var det = b * b - dot_op + sph.r * sph.r

    if (det < 0) { ret 0 }

    det = sqrt(det)
    var t1 = b - det
    if (t1 > 0.001) { ret t1 }

    var t2 = b + det
    if (t2 > 0.001) { ret t2 }

    ret 0
}

fn trace(ray: Ray, depth: num, scene: Sphere[], bg_white: Vec3, bg_blue: Vec3) {
    if (depth <= 0) {
        var black: Vec3 = {x:0, y:0, z:0}
        ret black
    }

    var t = 999999
    var id = -1
    var i = 0

    for (sph in scene) {
        var d = intersect(ray, sph)
        if (d > 0.001) {
            if (d < t) {
                t = d
                id = i
            }
        }
        i = i + 1
    }

    if (id != -1) {
        var obj: Sphere = scene[id]
        var hit: Vec3 = add_v(ray.o, mul_vs(ray.d, t))
        var n: Vec3 = norm(sub_v(hit, obj.p))

        if (dot(ray.d, n) > 0) {
            n = mul_vs(n, -1)
        }

        if (obj.mat_type == Material::diffuse) {
            var target: Vec3 = add_v(n, random_unit_vector())
            var bounce_ray: Ray = {o: hit, d: target}
            var bounce_color: Vec3 = trace(bounce_ray, depth - 1, scene, bg_white, bg_blue)
            ret mul_v(bounce_color, obj.c)
        }

        if (obj.mat_type == Material::metal) {
            var reflected: Vec3 = reflect(norm(ray.d), n)
            var target: Vec3 = add_v(reflected, mul_vs(random_unit_vector(), obj.fuzz))

            if (dot(target, n) > 0) {
                var bounce_ray: Ray = {o: hit, d: target}
                var bounce_color: Vec3 = trace(bounce_ray, depth - 1, scene, bg_white, bg_blue)
                ret mul_v(bounce_color, obj.c)
            }

            var black2: Vec3 = {x:0, y:0, z:0}
            ret black2
        }
    }

    var unit_dir: Vec3 = norm(ray.d)
    var t_bg = 0.5 * (unit_dir.y + 1.0)

    ret add_v(mul_vs(bg_white, 1.0 - t_bg), mul_vs(bg_blue, t_bg))
}

fn clamp(x: num) {
    if (x < 0) { ret 0 }
    if (x > 1) { ret 1 }
    ret x
}

// --- Multithreaded Core Function ---
fn render_core(start_y: num, end_y: num, out_pixels: num[], thread_id: num) {
    // Thread-Local Context: This guarantees each thread builds its own scene data in its own memory region!
    var cam_o: Vec3 = {x: 0, y: 1, z: 1}
    var bg_white: Vec3 = {x:1, y:1, z:1}
    var bg_blue: Vec3 = {x:0.5, y:0.7, z:1.0}
    var scene: Sphere[] = [
        {r: 1000, p: {x: 0, y: -1000, z: -1}, c: {x:0.5, y:0.5, z:0.5}, mat_type: Material::diffuse, fuzz: 0},
        {r: 0.5,  p: {x: 0, y: 0.5, z: -1.5},  c: {x:0.8, y:0.3, z:0.3}, mat_type: Material::diffuse, fuzz: 0},
        {r: 0.5,  p: {x: -1.1, y: 0.5, z: -1.5}, c: {x:0.8, y:0.8, z:0.8}, mat_type: Material::metal, fuzz: 0.1},
        {r: 0.5,  p: {x: 1.1, y: 0.5, z: -1.5},  c: {x:0.8, y:0.6, z:0.2}, mat_type: Material::metal, fuzz: 0.8}
    ]

    var y = start_y
    var idx = 0

    for (y < end_y) {
        var x = 0
        for (x < width) {
            var pixel_color: Vec3 = {x:0, y:0, z:0}
            var s = 0

            for (s < samples) {
                var u = (x + rand() - width/2) / width
                var v = (y + rand() - height/2) / height
                var dir: Vec3 = norm({x: u, y: -v, z: -1})
                var r: Ray = {o: cam_o, d: dir}
                var col: Vec3 = trace(r, max_depth, scene, bg_white, bg_blue)

                pixel_color.x = pixel_color.x + col.x
                pixel_color.y = pixel_color.y + col.y
                pixel_color.z = pixel_color.z + col.z
                s = s + 1
            }

            pixel_color = mul_vs(pixel_color, 1.0 / samples)

            out_pixels[idx]   = floor(clamp(sqrt(pixel_color.x)) * 255)
            out_pixels[idx+1] = floor(clamp(sqrt(pixel_color.y)) * 255)
            out_pixels[idx+2] = floor(clamp(sqrt(pixel_color.z)) * 255)

            idx = idx + 3
            x = x + 1
        }
        y = y + 1

        // Broadcast completed rows to the main thread
        bus_set(f"{thread_id}", y - start_y)
    }
}

// --- Define Regions and Job Wrappers ---
var chunk_rows = height / 4
var chunk_pixels = width * chunk_rows * 3

region r0
var r0::start_y = 0
var r0::end_y = chunk_rows
var r0::pixels = list(chunk_pixels)
fn task0() { render_core(r0::start_y, r0::end_y, r0::pixels, 0) }

region r1
var r1::start_y = chunk_rows
var r1::end_y = chunk_rows * 2
var r1::pixels = list(chunk_pixels)
fn task1() { render_core(r1::start_y, r1::end_y, r1::pixels, 1) }

region r2
var r2::start_y = chunk_rows * 2
var r2::end_y = chunk_rows * 3
var r2::pixels = list(chunk_pixels)
fn task2() { render_core(r2::start_y, r2::end_y, r2::pixels, 2) }

region r3
var r3::start_y = chunk_rows * 3
var r3::end_y = height
var r3::pixels = list(chunk_pixels)
fn task3() { render_core(r3::start_y, r3::end_y, r3::pixels, 3) }


// --- Execution & Thread Assembly ---
print("Starting 1080p RTIOW Multithreaded Render...")

// Initialize the bus channels to 0 so the main thread doesn't read garbage
bus_set("0", 0)
bus_set("1", 0)
bus_set("2", 0)
bus_set("3", 0)

// Spawn the workers
var w0 = create_worker(r0, "task0")
var w1 = create_worker(r1, "task1")
var w2 = create_worker(r2, "task2")
var w3 = create_worker(r3, "task3")

print("Workers spawned. Monitoring progress...")

var total_done = 0
var last_pct = -1

// Poll the bus channels while the workers run
for (total_done < height) {
    // Read the completed rows from each thread's channel
    var d0 = bus_get("0")
    var d1 = bus_get("1")
    var d2 = bus_get("2")
    var d3 = bus_get("3")

    total_done = d0 + d1 + d2 + d3
    var pct = floor((total_done / height) * 100)

    // Only print when the percentage changes to avoid terminal spam
    if (pct > last_pct) {
        var bar_len = pct / 5  // Creates a 20-character bar
        var bar = ""
        var i = 0
        for (i < 20) {
            if (i < bar_len) { bar = bar + "#" }
            else { bar = bar + "-" }
            i = i + 1
        }

        print(f"[{bar}] {pct}% - {total_done}/{height} rows")
        last_pct = pct
    }
}

print("All rows rendered! Docking threads...")

// Safely retrieve the memory regions now that we know they are done
dock_worker(w0)
dock_worker(w1)
dock_worker(w2)
dock_worker(w3)

print("Threads rejoined successfully. Assembling image...")

// Re-combine the chunks
var final_pixels = r0::pixels + r1::pixels
final_pixels = final_pixels + r2::pixels
final_pixels = final_pixels + r3::pixels

var header = [80, 54, 10, 49, 57, 50, 48, 32, 49, 48, 56, 48, 10, 50, 53, 53, 10]
write_bytes("rtiow_1080p.ppm", header + final_pixels)

print("Render complete! Saved to rtiow_1080p.ppm")