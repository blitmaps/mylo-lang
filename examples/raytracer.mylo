// --- Vector Math & Structs ---
struct Vec3 { 
    var x
    var y
    var z 
}

fn add_v(a: Vec3, b: Vec3) { 
    var r: Vec3 = {x: a.x + b.x, y: a.y + b.y, z: a.z + b.z}
    ret r 
}

fn sub_v(a: Vec3, b: Vec3) { 
    var r: Vec3 = {x: a.x - b.x, y: a.y - b.y, z: a.z - b.z}
    ret r 
}

fn mul_vs(a: Vec3, s: num) { 
    var r: Vec3 = {x: a.x * s, y: a.y * s, z: a.z * s}
    ret r 
}

fn mul_v(a: Vec3, b: Vec3) { 
    var r: Vec3 = {x: a.x * b.x, y: a.y * b.y, z: a.z * b.z}
    ret r 
}

fn dot(a: Vec3, b: Vec3) { 
    ret a.x * b.x + a.y * b.y + a.z * b.z 
}

fn norm(v: Vec3) {
    var mag = sqrt(dot(v, v))
    if (mag == 0) { 
        var z: Vec3 = {x:0, y:0, z:0}
        ret z 
    }
    var r: Vec3 = {x: v.x/mag, y: v.y/mag, z: v.z/mag}
    ret r
}

fn reflect(v: Vec3, n: Vec3) {
    var dot_vn = dot(v, n)
    var n_scaled = mul_vs(n, 2 * dot_vn)
    ret sub_v(v, n_scaled)
}

fn random_unit_vector() {
    var v: Vec3 = {x: rand_normal(), y: rand_normal(), z: rand_normal()}
    ret norm(v)
}

// --- Scene Definitions ---
enum Material { 
    diffuse, 
    metal 
}

struct Ray { 
    var o: Vec3
    var d: Vec3 
}

struct Sphere {
    var r     
    var p: Vec3     
    var c: Vec3     
    var mat_type 
    var fuzz  
}

var scene: Sphere[] = [
    {r: 1000, p: {x: 0, y: -1000, z: -1}, c: {x:0.5, y:0.5, z:0.5}, mat_type: Material::diffuse, fuzz: 0},
    {r: 0.5,  p: {x: 0, y: 0.5, z: -1.5},  c: {x:0.8, y:0.3, z:0.3}, mat_type: Material::diffuse, fuzz: 0},
    {r: 0.5,  p: {x: -1.1, y: 0.5, z: -1.5}, c: {x:0.8, y:0.8, z:0.8}, mat_type: Material::metal, fuzz: 0.1},
    {r: 0.5,  p: {x: 1.1, y: 0.5, z: -1.5},  c: {x:0.8, y:0.6, z:0.2}, mat_type: Material::metal, fuzz: 0.8}
]

var bg_white: Vec3 = {x:1, y:1, z:1}
var bg_blue: Vec3 = {x:0.5, y:0.7, z:1.0}

// --- Core Raytracing ---
fn intersect(ray: Ray, sph: Sphere) {
    var p: Vec3 = sph.p
    var o: Vec3 = ray.o
    var d: Vec3 = ray.d
    
    var op_x = p.x - o.x
    var op_y = p.y - o.y
    var op_z = p.z - o.z
    
    var b = (op_x * d.x) + (op_y * d.y) + (op_z * d.z)
    var dot_op = (op_x * op_x) + (op_y * op_y) + (op_z * op_z)
    
    var det = b * b - dot_op + sph.r * sph.r
    
    if (det < 0) { 
        ret 0 
    }
    
    det = sqrt(det)
    var t1 = b - det
    
    if (t1 > 0.001) { 
        ret t1 
    }
    
    var t2 = b + det
    if (t2 > 0.001) { 
        ret t2 
    }
    
    ret 0
}

fn trace(ray: Ray, depth: num) {
    if (depth <= 0) { 
        var black: Vec3 = {x:0, y:0, z:0}
        ret black 
    }
    
    var t = 999999
    var id = -1
    var i = 0
    
    for (sph in scene) {
        var d = intersect(ray, sph)
        if (d > 0.001) {
            if (d < t) { 
                t = d
                id = i 
            }
        }
        i = i + 1
    }
    
    if (id != -1) { 
        var obj: Sphere = scene[id]
        var hit: Vec3 = add_v(ray.o, mul_vs(ray.d, t))
        var n: Vec3 = norm(sub_v(hit, obj.p))
        
        if (dot(ray.d, n) > 0) { 
            n = mul_vs(n, -1) 
        }
        
        if (obj.mat_type == Material::diffuse) {
            var target: Vec3 = add_v(n, random_unit_vector())
            var bounce_ray: Ray = {o: hit, d: target}
            var bounce_color: Vec3 = trace(bounce_ray, depth - 1)
            ret mul_v(bounce_color, obj.c)
        }
        
        if (obj.mat_type == Material::metal) {
            var reflected: Vec3 = reflect(norm(ray.d), n)
            var target: Vec3 = add_v(reflected, mul_vs(random_unit_vector(), obj.fuzz))
            
            if (dot(target, n) > 0) {
                var bounce_ray: Ray = {o: hit, d: target}
                var bounce_color: Vec3 = trace(bounce_ray, depth - 1)
                ret mul_v(bounce_color, obj.c)
            }
            
            var black2: Vec3 = {x:0, y:0, z:0}
            ret black2
        }
    }
    
    var unit_dir: Vec3 = norm(ray.d)
    var t_bg = 0.5 * (unit_dir.y + 1.0)
    
    ret add_v(mul_vs(bg_white, 1.0 - t_bg), mul_vs(bg_blue, t_bg))
}

fn clamp(x: num) { 
    if (x < 0) { 
        ret 0 
    } 
    if (x > 1) { 
        ret 1 
    } 
    ret x 
}

// --- Main Render Loop ---
print("Starting RTIOW render...")
var width = 256
var height = 256
var samples = 10
var max_depth = 5

var header = [80, 54, 10, 50, 53, 54, 32, 50, 53, 54, 10, 50, 53, 53, 10]
var pixels = list(width * height * 3)
var idx = 0
var cam_o: Vec3 = {x: 0, y: 1, z: 1} 

var y = 0
var comp = 0
for (y <= 255) {
    var x = 0
    for (x <= 255) {
        var pixel_color: Vec3 = {x:0, y:0, z:0}
        var s = 0
        
        for (s < samples) {
            var u = (x + rand() - width/2) / width
            var v = (y + rand() - height/2) / height
            var dir: Vec3 = norm({x: u, y: -v, z: -1})
            
            var r: Ray = {o: cam_o, d: dir}
            var col: Vec3 = trace(r, max_depth)
            
            // THE FIX: Mutate pixel_color in-place so it survives the loop sweep!
            pixel_color.x = pixel_color.x + col.x
            pixel_color.y = pixel_color.y + col.y
            pixel_color.z = pixel_color.z + col.z
            
            s = s + 1
        }

        pixel_color = mul_vs(pixel_color, 1.0 / samples)
        
        pixels[idx]   = floor(clamp(sqrt(pixel_color.x)) * 255)
        pixels[idx+1] = floor(clamp(sqrt(pixel_color.y)) * 255)
        pixels[idx+2] = floor(clamp(sqrt(pixel_color.z)) * 255)
        
        idx = idx + 3
        x = x + 1
        comp = comp+1
    }
    y = y + 1
    var ras:i32 = (comp / (width * height))*100
    print(f"Rendering Rasterline : {y}, [{ras} % Complete].")
}

write_bytes("rtiow.ppm", header + pixels)
print("Done!")
